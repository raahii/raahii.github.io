<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>prometheus on 1ミリもわからん</title><link>https://raahii.github.io/tags/prometheus/</link><description>Recent content in prometheus on 1ミリもわからん</description><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><lastBuildDate>Sun, 31 May 2020 17:20:27 +0900</lastBuildDate><atom:link href="https://raahii.github.io/tags/prometheus/index.xml" rel="self" type="application/rss+xml"/><item><title>ProxySQLでMySQLの負荷分散をする</title><link>https://raahii.github.io/posts/docker-proxysql-mysql-replication/</link><pubDate>Sun, 31 May 2020 17:20:27 +0900</pubDate><guid>https://raahii.github.io/posts/docker-proxysql-mysql-replication/</guid><description>はじめに 前回、MySQLのmaster slave構成をDockerで作ってみた が、実際の開発では複数DBをアプリケーションから使うには一工夫必要である。もっとも素朴な方法は使用するDBの接続情報をアプリケーションですべて保持しておき、read系/write系で使い分けることだと思う。しかし、これは次のような問題がある。
DBの接続情報は途中で変わりうる アプリケーションのロジックにDBの使い分けが入るのは面倒（だし複雑） そこで、今回は ProxySQL を試してみる。ProxySQLは アプリケーションとDBの間に入って、次のようなことをしてくれる。
クエリに応じたmaster / slave への自動プロキシ 負荷分散 シームレスな接続設定の変更 どの程度メジャーなのかはいまいちわかっていないが、公式の mysql-proxyよりは使われているようだったので選んだ。ちなみにProxySQLはMysQL以外のDBでも使える。
MySQLのセットアップ 前回に続いてMySQL8.0を使い、masterを1つ、slaveを2つ用意してレプリケーション設定を組んでおいた。
version: &amp;#34;3&amp;#34;services: mysql-master: image: mysql:8.0 container_name: proxysql-mysql-replication-master environment: MYSQL_ROOT_PASSWORD: password MYSQL_DATABASE: sbtest volumes: - ./master/my.cnf:/etc/mysql/my.cnf - ./master/data:/var/lib/mysql - ./master/init.sql:/docker-entrypoint-initdb.d/init.sql ports: - 3306:3306 mysql-slave1: image: mysql:8.0 container_name: proxysql-mysql-replication-slave1 environment: MYSQL_ROOT_PASSWORD: password MYSQL_DATABASE: sbtest volumes: - ./slave/my-slave1.cnf:/etc/mysql/my.cnf - ./slave/data/slave1:/var/lib/mysql - ./slave/init.sql:/docker-entrypoint-initdb.d/init.sql ports: - 3307:3306 depends_on: - mysql-master mysql-slave2: image: mysql:8.</description></item></channel></rss>