<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>coc.nvim on 1ミリもわからん</title><link>https://raahii.github.io/tags/coc.nvim/</link><description>Recent content in coc.nvim on 1ミリもわからん</description><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><lastBuildDate>Tue, 20 Sep 2022 00:30:00 +0900</lastBuildDate><atom:link href="https://raahii.github.io/tags/coc.nvim/index.xml" rel="self" type="application/rss+xml"/><item><title>Vim ALE と sql-formatter で SQL を整形する</title><link>https://raahii.github.io/posts/vim-ale-sql-formatter/</link><pubDate>Tue, 20 Sep 2022 00:30:00 +0900</pubDate><guid>https://raahii.github.io/posts/vim-ale-sql-formatter/</guid><description>最近データベーススペシャリストの勉強をしながら SQL を書いている中で、フォーマッタがほしいなと思ったので色々調査していた。Vim に ALE というリンタプラグインがあるが、公式でサポートしている SQL 向けのフォーマットは下記の4つだ（2022/09 時点）。
dprint pgformatter sqlfmt sqlformat ale/ale-sql.txt · dense-analysis/ale
一通り使ってみた中では pgformatter が良かった。設定が豊富で、それらを ~/.pg_format で管理することもできる。特に、コンマを行頭に持ってこれる整形オプションが好きで、こんなSQLが、
SELECTpo.idproduct_order_id,p.idproduct_id,p.nameproduct_name,po.num_ordersFROMproduct_orderpoJOINproductpONp.id=po.product_idWHEREp.is_set_product=TRUEこんな風にフォーマットされて良い。
SELECTpo.idproduct_order_id,p.idproduct_id,p.nameproduct_name,po.num_ordersFROMproduct_orderpoJOINproductpONp.id=po.product_idWHEREp.is_set_product=TRUEところが、使っている中でコメント周りやサブクエリ周りの整形が微妙なことがわかったのと、pgformatter は PostgreSQL 向けなのに対し、私は MySQL 向けのSQLを書くことが多いので、代替を探していた。
すると、巷では明らかに sql-formatter-org/sql-formatter が使われているようだった。例えばcoc-sql も採用している。サポートしているクエリ言語も手広いので、これを採用して ALE に組み込むことにした。
ALE では次のように任意のコマンドを組み込める。-l の言語指定はお好みで。
let g:ale_fixers = { ... \ &amp;#39;sql&amp;#39;: [ \ { buffer -&amp;gt; { \ &amp;#39;command&amp;#39;: &amp;#39;sql-formatter -l mysql&amp;#39; \ }}, \ ] \} これでめっちゃ快適にSQLを書けるようになった。
余談だが、仕事でもクエリを管理するためのレポがあって、DBオペの度にそこでレビュー受けてから実行するような運用なのだけれど、書き方が結構バラバラなので導入してみようかな。そういうチョットしたものでも、フォーマッタがある方が書く側もレビューする側も余計な時間を使わずに済んで良い。
あと、LSP があるのでなぜ未だに ALE つかっているの？と思う人もいるかも知れない。私は coc.</description></item><item><title>coc.nvim で golint を使う</title><link>https://raahii.github.io/posts/setup-golint-coc-nvim/</link><pubDate>Mon, 11 May 2020 11:34:15 +0900</pubDate><guid>https://raahii.github.io/posts/setup-golint-coc-nvim/</guid><description>coc.nvim は VimのLSPプラグインの一つで、コード補完や定義ジャンプを提供したり、ドキュメントを良い感じに出してくれる。cocはプラグインであるにも関わらず、それ自体が拡張機能（エクステンション）を持っており、使いたい言語の拡張を入れるだけで細かい設定が要らないのが大きな特徴である。あとFloating Windowの表示がきれい。
ただ、個人的にLSPプラグインはリント・コードフォーマットの組み合わせ方が難しいと思っている。なぜなら、cocはいずれの機能も提供するものの、特定のフォーマッタをピンポイントで入れるというのがなかなか難しいからである。拡張が設定を用意していない限り、カスタマイズが難しい。
なので自分は、LSPには基本的な補完機能とリントを、aleにコードフォーマットを任せている。こうすることで、cocの快適な機能を享受しつつも、aleで非同期に（カーソル動作をブロックせずに）コードフォーマットも行えている。
本題になるが、今、自分はGoのLSPである gopls を使っており、これは coc-go が提供するが、残念がら golint を使うことはできない。リントをcocに任せている以上、golintもLSPとして連携されなければならない、という問題がある。
こう言うときに使えるのが diagnostic-languageserver である。これは、任意のコマンドをLSP化してくれるもので、coc向けには coc-diagnostic が提供されている。これを活用することで、例えば JSのeslintやdockerfileのhadolintなんかもLSPとして組み込むことができる（！）
以下、導入方法を順に説明すると、
coc-diagnosticをインストールする。
:CocInstall coc-diagnostic でも良いし、 Vim Plugで管理しているのであれば
Plug &amp;#39;iamcco/coc-diagnostic&amp;#39;, {&amp;#39;do&amp;#39;: &amp;#39;yarn install --frozen-lockfile &amp;amp;&amp;amp; yarn build&amp;#39;} と書くこともできる。
golintをインストールする。
地味に気づかなかったりるけど、入っていないと当然動かない。
go get github.com/golang/lint coc-settings.json に下記を設定する
{ ... &amp;#34;languageserver&amp;#34;: { &amp;#34;dls&amp;#34;: { &amp;#34;command&amp;#34;: &amp;#34;diagnostic-languageserver&amp;#34;, &amp;#34;args&amp;#34;: [&amp;#34;--stdio&amp;#34;], &amp;#34;filetypes&amp;#34;: [ &amp;#34;go&amp;#34; ], &amp;#34;initializationOptions&amp;#34;: { &amp;#34;linters&amp;#34;: { &amp;#34;golint&amp;#34;: { &amp;#34;command&amp;#34;: &amp;#34;golint&amp;#34;, &amp;#34;rootPatterns&amp;#34;: [], &amp;#34;isStdout&amp;#34;: true, &amp;#34;isStderr&amp;#34;: false, &amp;#34;debounce&amp;#34;: 100, &amp;#34;args&amp;#34;: [&amp;#34;%filepath&amp;#34;], &amp;#34;offsetLine&amp;#34;: 0, &amp;#34;offsetColumn&amp;#34;: 0, &amp;#34;sourceName&amp;#34;: &amp;#34;golint&amp;#34;, &amp;#34;formatLines&amp;#34;: 1, &amp;#34;formatPattern&amp;#34;: [ &amp;#34;^[^:]+:(\\d+):(\\d+):\\s(.</description></item></channel></rss>