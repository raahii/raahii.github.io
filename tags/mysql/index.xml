<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mysql on 1ミリもわからん</title><link>https://raahii.github.io/tags/mysql/</link><description>Recent content in mysql on 1ミリもわからん</description><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><lastBuildDate>Tue, 20 Sep 2022 00:30:00 +0900</lastBuildDate><atom:link href="https://raahii.github.io/tags/mysql/index.xml" rel="self" type="application/rss+xml"/><item><title>Vim ALE と sql-formatter で SQL を整形する</title><link>https://raahii.github.io/posts/vim-ale-sql-formatter/</link><pubDate>Tue, 20 Sep 2022 00:30:00 +0900</pubDate><guid>https://raahii.github.io/posts/vim-ale-sql-formatter/</guid><description>最近データベーススペシャリストの勉強をしながら SQL を書いている中で、フォーマッタがほしいなと思ったので色々調査していた。Vim に ALE というリンタプラグインがあるが、公式でサポートしている SQL 向けのフォーマットは下記の4つだ（2022/09 時点）。
dprint pgformatter sqlfmt sqlformat ale/ale-sql.txt · dense-analysis/ale
一通り使ってみた中では pgformatter が良かった。設定が豊富で、それらを ~/.pg_format で管理することもできる。特に、コンマを行頭に持ってこれる整形オプションが好きで、こんなSQLが、
SELECTpo.idproduct_order_id,p.idproduct_id,p.nameproduct_name,po.num_ordersFROMproduct_orderpoJOINproductpONp.id=po.product_idWHEREp.is_set_product=TRUEこんな風にフォーマットされて良い。
SELECTpo.idproduct_order_id,p.idproduct_id,p.nameproduct_name,po.num_ordersFROMproduct_orderpoJOINproductpONp.id=po.product_idWHEREp.is_set_product=TRUEところが、使っている中でコメント周りやサブクエリ周りの整形が微妙なことがわかったのと、pgformatter は PostgreSQL 向けなのに対し、私は MySQL 向けのSQLを書くことが多いので、代替を探していた。
すると、巷では明らかに sql-formatter-org/sql-formatter が使われているようだった。例えばcoc-sql も採用している。サポートしているクエリ言語も手広いので、これを採用して ALE に組み込むことにした。
ALE では次のように任意のコマンドを組み込める。-l の言語指定はお好みで。
let g:ale_fixers = { ... \ &amp;#39;sql&amp;#39;: [ \ { buffer -&amp;gt; { \ &amp;#39;command&amp;#39;: &amp;#39;sql-formatter -l mysql&amp;#39; \ }}, \ ] \} これでめっちゃ快適にSQLを書けるようになった。
余談だが、仕事でもクエリを管理するためのレポがあって、DBオペの度にそこでレビュー受けてから実行するような運用なのだけれど、書き方が結構バラバラなので導入してみようかな。そういうチョットしたものでも、フォーマッタがある方が書く側もレビューする側も余計な時間を使わずに済んで良い。
あと、LSP があるのでなぜ未だに ALE つかっているの？と思う人もいるかも知れない。私は coc.</description></item><item><title>ProxySQLでMySQLの負荷分散をする</title><link>https://raahii.github.io/posts/docker-proxysql-mysql-replication/</link><pubDate>Sun, 31 May 2020 17:20:27 +0900</pubDate><guid>https://raahii.github.io/posts/docker-proxysql-mysql-replication/</guid><description>はじめに 前回、MySQLのmaster slave構成をDockerで作ってみた が、実際の開発では複数DBをアプリケーションから使うには一工夫必要である。もっとも素朴な方法は使用するDBの接続情報をアプリケーションですべて保持しておき、read系/write系で使い分けることだと思う。しかし、これは次のような問題がある。
DBの接続情報は途中で変わりうる アプリケーションのロジックにDBの使い分けが入るのは面倒（だし複雑） そこで、今回は ProxySQL を試してみる。ProxySQLは アプリケーションとDBの間に入って、次のようなことをしてくれる。
クエリに応じたmaster / slave への自動プロキシ 負荷分散 シームレスな接続設定の変更 どの程度メジャーなのかはいまいちわかっていないが、公式の mysql-proxyよりは使われているようだったので選んだ。ちなみにProxySQLはMysQL以外のDBでも使える。
MySQLのセットアップ 前回に続いてMySQL8.0を使い、masterを1つ、slaveを2つ用意してレプリケーション設定を組んでおいた。
version: &amp;#34;3&amp;#34;services: mysql-master: image: mysql:8.0 container_name: proxysql-mysql-replication-master environment: MYSQL_ROOT_PASSWORD: password MYSQL_DATABASE: sbtest volumes: - ./master/my.cnf:/etc/mysql/my.cnf - ./master/data:/var/lib/mysql - ./master/init.sql:/docker-entrypoint-initdb.d/init.sql ports: - 3306:3306 mysql-slave1: image: mysql:8.0 container_name: proxysql-mysql-replication-slave1 environment: MYSQL_ROOT_PASSWORD: password MYSQL_DATABASE: sbtest volumes: - ./slave/my-slave1.cnf:/etc/mysql/my.cnf - ./slave/data/slave1:/var/lib/mysql - ./slave/init.sql:/docker-entrypoint-initdb.d/init.sql ports: - 3307:3306 depends_on: - mysql-master mysql-slave2: image: mysql:8.</description></item><item><title>MySQLのmaster slave構成をDockerで試す</title><link>https://raahii.github.io/posts/docker-mysql-master-slave-replication/</link><pubDate>Thu, 28 May 2020 23:43:16 +0900</pubDate><guid>https://raahii.github.io/posts/docker-mysql-master-slave-replication/</guid><description>研修で触ったときにサクッと動かなかったので追試的に。MySQLは8.0を使う。
レプリケーション自体の仕組みは 進化を続けるMySQLのド定番機能　MySQLレプリケーション最新機能 がわかりやすかった。
必要なこと How To Set Up Master Slave Replication in MySQL | DigitalOcean
このページを見ながらmasterとslaveのmysqldを1つずつ用意して、設定を行う。異なる点は下記。
master, slave共に bind-addressを0.0.0.0として、dockerのネットワークエイリアスで繋ぐ
masterのMySQLにレプリケーション用のユーザーを作成するが、MySQL8.0ではGRANT構文でユーザを作成できない ので下記のようにする
create user &amp;#39;slave_user&amp;#39;@&amp;#39;%&amp;#39; identified by &amp;#39;password&amp;#39;; grant replication slave on *.* to &amp;#39;slave_user&amp;#39;@&amp;#39;%&amp;#39; with grant option; flush privileges; GTIDを有効にして MASTER_LOG_FILE と MASTER_LOG_POS は自動で検知されるようにする。 CHANGE MASTER TO MASTER_HOST=&amp;#39;mysql-master&amp;#39;,MASTER_USER=&amp;#39;slave_user&amp;#39;,MASTER_PASSWORD=&amp;#39;password&amp;#39;,MASTER_AUTO_POSITION=1; START SLAVE; レプリケーションを確認する $ git clone https://github.com/raahii/docker-mysql-master-slave.git $ cd docker-mysql-master-slave $ docker-compose up -d $ docker-compose ps Name Command State Ports -------------------------------------------------------------------------------------- mysql-master docker-entrypoint.</description></item></channel></rss>